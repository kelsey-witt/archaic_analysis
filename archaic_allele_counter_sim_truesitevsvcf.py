"""
This script was written by Kelsey Witt in November 2021. The goal of this script is
to take a simulated VCF of European, East Asian and African genomes and identify
archaic SNPs (and the criteria are that the allele has to be found in Africans
at a frequency of less than 1% and at a frequency of at least 1% in at least one
non-African population, and shared with the simulated Neanderthal genome).

Usage: python3 archaic_allele_counter_sim_truesitevsvcf.py

The input file is a vcf file generated by simulations using lewotin_sim_truesites.py
(infile, line 79).

This script generates a tab-delimited file (nea_sim_trueSiteVSvcf_estimatedSiteList#.txt)
where each row lists a position within the simulated chromosome and the leaf IDs that
have that archaic site. An archaic site must be shared with the simulated Neanderthal
chromosome, present in Africans at a frequency of less than 1% and present in non-African
populations with a frequency of at least 1%.
"""

import gzip
import re
import sys
import csv
import random

populations = ["YRI", "CEU", "CHB"]
Pop_Tracker = {}

for pop in populations:
    Pop_Tracker[pop] = []

chr_list = ["21"]

col_counter = 9
for colNum in range(9,608):
    if colNum < 213: #
        Pop_Tracker["YRI"].append(colNum)
    elif colNum < 411:
        Pop_Tracker["CEU"].append(colNum)
    elif colNum < 617:
        Pop_Tracker["CHB"].append(colNum)

archCol1 = 617
archCol2 = 618

def decode_split_line(line):
    line = str(line.decode('utf-8'))
    if '#' not in line:
        line = line.split()
    return line

def parse_mod_line(line):
    position, _, ref_allele, mod_alt_allele = line[1:5]
    mod_info = line[7]
    return [position, ref_allele, mod_alt_allele, mod_info]

def calc_afr_allele_freq(line):
    afr_allele_total = len(Pop_Tracker["YRI"]) * 2
    afr_allele_1_sum = 0
    for afr_ind in Pop_Tracker["YRI"]:
        afr_allele_1_sum += line[afr_ind].count("1")
    afr_allele_1_fq = float(afr_allele_1_sum/afr_allele_total)
    afr_allele_1_round = round(afr_allele_1_fq)
    return afr_allele_1_round

def identify_non_afr_alleles(line):
    non_afr_allele = "null"
    afr_alt_af = calc_afr_allele_freq(line)
    if afr_alt_af < 0.01 or afr_alt_af > 0.99:
        if afr_alt_af < 0.01: #allele of interest is alternate
            non_afr_allele = "1"
        else: #allele of interest is reference
            non_afr_allele = "0"
    return non_afr_allele

for i in range(1,21): #number of simulations
    infile = "nea_sim_trueSiteVSvcf_" + str(i) + ".vcf"
    sitesOutfile = "nea_sim_trueSiteVSvcf_estimatedSiteList" + str(i) + ".txt"
    g = open(sitesOutfile, 'w')
    headCols = ["position","leaves"]
    headLine = "\t".join(headCols) + "\n"
    g.write(headLine)
    for chromosome in chr_list:
        with open(infile) as mf:
            for mod_line in mf:
                alleleAncient = False
                if '#' not in mod_line:
                    modSpline = mod_line.split()
                    mod_position = modSpline[1]
                    non_afr_allele = identify_non_afr_alleles(mod_line)
                    if non_afr_allele in modSpline[archCol1] or non_afr_allele in modSpline[archCol2]:
                        popList = set()
                        leafOut = ""
                        for pop in populations[1:]:
                            for ind in Pop_Tracker[pop]:
                                if non_afr_allele in modSpline[ind]:
                                    indID = ind-9
                                    leafOut += str(indID) + ","
                        leafOut = leafOut[:-1]
                        outCols=[str(mod_position),leafOut]
                        outLine = "\t".join(outCols) + "\n"
                        g.write(outLine)

